/*
 * This program generates the xlat_tree.py Python module
 * for use by anglicize.py.
 *
 * The are no command line arguments -- the program
 * silently creates or overwrites xlat_tree.py in
 * the current working directory.
 *
 * Please send any improvements, suggestions, and
 * bugfixes to him@revl.org.
 */

#include <stdio.h>

#include <map>

// UTF-8 char to roman representation correspondence.
struct XLatEntry
{
	const char* from;
	const char* to;
};

// Load input data.
#include "xlat_entries.h"

#define NUMBER_OF_ENTRIES (sizeof(xlat_entries) / sizeof(*xlat_entries))

struct XLatTreeNode;

// NodeMap matches the xlat_tree structure in the resulting
// xlat_tree.py Python module.
typedef std::map<char, XLatTreeNode*> NodeMap;

struct XLatTreeNode
{
	const char* encoded;
	NodeMap children;

	XLatTreeNode(const char* encoded) : encoded(encoded)
	{
	}
};

// This class builds a tree out of byte sequences of
// the input UTF-8 characters.
class XLatTreeGenerator
{
public:
	void AddXLatEntry(const XLatEntry* xlat_entry);
	void DumpXLatTree(FILE* output_file);

private:
	void PrintIndent(int indent, FILE* output_file);
	void DumpTreeNode(FILE* output_file, NodeMap* tree_node, int indent);

	NodeMap xlat_tree_root;
};

// This is the main procedure.
void XLatTreeGenerator::AddXLatEntry(const XLatEntry* xlat_entry)
{
	const char* ch = xlat_entry->from;
	NodeMap* tree_node = &xlat_tree_root;

	// Create nodes in the output tree for all but one
	// bytes in the input UTF-8 character.
	while (ch[1] != '\0')
	{
		std::pair<NodeMap::iterator, bool> insertion =
				tree_node->insert(
						NodeMap::value_type(*ch, NULL));
		if (insertion.second)
			insertion.first->second = new XLatTreeNode(NULL);
		tree_node = &insertion.first->second->children;
		++ch;
	}

	// Mark the node of the last byte as "finite" by assigning the
	// transliteration of the UTF-character to it.
	std::pair<NodeMap::iterator, bool> insertion =
			tree_node->insert(NodeMap::value_type(*ch, NULL));
	if (insertion.second)
		insertion.first->second = new XLatTreeNode(xlat_entry->to);
	else
		insertion.first->second->encoded = xlat_entry->to;
}

void XLatTreeGenerator::DumpXLatTree(FILE* output_file)
{
	fprintf(output_file, "# This file is generated by make_xlat_tree.\n"
			"# All changes made in this file will be lost.\n"
			"\n"
			"xlat_tree = ");
	DumpTreeNode(output_file, &xlat_tree_root, 0);
	putc('\n', output_file);
}

void XLatTreeGenerator::PrintIndent(int indent, FILE* output_file)
{
	while (--indent >= 0)
		fprintf(output_file, "    ");
}

void XLatTreeGenerator::DumpTreeNode(
		FILE* output_file, NodeMap* tree_node, int indent)
{
	fprintf(output_file, "{\n");
	NodeMap::const_iterator it = tree_node->begin();
	for (;;)
	{
		PrintIndent(indent + 1, output_file);
		fprintf(output_file, "'\\x%02x': [\"%s\", ",
				(int) (unsigned char) it->first,
				it->second->encoded ? it->second->encoded : "");
		if (it->second->children.empty())
			fprintf(output_file, "None");
		else
			DumpTreeNode(output_file,
					&it->second->children, indent + 1);
		if (++it != tree_node->end())
			fprintf(output_file, "],\n");
		else
		{
			fprintf(output_file, "]\n");
			break;
		}
	}
	PrintIndent(indent, output_file);
	putc('}', output_file);
}

int main(int argc, const char* argv[])
{
	if (argc != 2)
	{
		fprintf(stderr, "Usage: %s OUTPUT_FILE\n", *argv);
		return 1;
	}

	const char* output_file_name = argv[1];

	FILE* output_file = fopen(output_file_name, "wt");
	if (output_file == NULL)
	{
		perror(output_file_name);
		return 2;
	}

	XLatTreeGenerator generator;

	// For each input UTF-8 character.
	for (int i = 0; i < NUMBER_OF_ENTRIES; ++i)
		generator.AddXLatEntry(xlat_entries + i);

	generator.DumpXLatTree(output_file);

	fclose(output_file);

	return 0;
}
